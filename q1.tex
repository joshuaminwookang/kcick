
\documentclass{article}

\usepackage{fancyhdr, extramarks, amsmath, amsthm, amsfonts, tikz, titling}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode, forest, listings, forest}
\usetikzlibrary{automata,positioning}

% Basic Document Settings
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in
\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\rfoot{\hmwkTitle}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\setlength\parindent{0pt}

% Create Problem Sections

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Q1. Minimal Project Prototype}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{ \exitProblemHeader{homeworkProblemCounter}}
%
% Homework Details
%
\newcommand{\hmwkTitle}{Homework 9}
\newcommand{\hmwkDueDate}{November 15, 2018}
\newcommand{\hmwkClass}{CSCI 334 Principles of PL }
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Professor Dan Barowy}
\newcommand{\hmwkAuthorName}{{3013644,3023651}}

%
% Various Helper Commands
%
% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}
% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}
% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}
% Integral dx
\newcommand{\dx}{\mathrm{d}x}
% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}
% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\renewcommand{\maketitle}{\bgroup\vspace*{-0.75in}
\setlength{\parindent}{0pt}
\begin{flushleft}
\noindent\rule{6.5in}{0.6pt}\\[3mm]
{\Large\textbf{\hmwkClass: \hmwkTitle}}\\[2mm]
\textit{\hmwkClassInstructor\ \hmwkClassTime} \\ 
\normalsize {\small Due:\ \hmwkDueDate\ at 10:00pm} \hfill 
\textbf{ID: 3013644, 3023651 $\;$}\\
\noindent\rule{6.5in}{0.6pt}
\end{flushleft}\egroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\thispagestyle{plain}
\maketitle
\renewcommand{\part}[1]{\textbf{\large Part
\Alph{partCounter}}\stepcounter{partCounter}\\}

\begin{homeworkProblem}
\vspace{20pt}
\begin{center}
{\fontfamily{qcr}\selectfont
\Large{\textbf{"KCICK: the \underline{K}CICK  \underline{C}onsulting \underline{I}nterview \underline{C}rac\underline{K}er"}}
}
\end{center}
\fontfamily{phv}\selectfont
\vspace{20pt}
{\large \textbf{(a) Introduction }} \\

Management consulting is a dream job for every Williams student. Well, at least that's what our \textit{non-CS} friends say.\\ 

One of the most notorious aspects of consulting interviews are the Fermi problems. These are problems that require a fast and rough estimation of quantities that may be hard to measure physically. One example of a Fermi problem is "How many tennis balls could fit in an Olympic sized pool?" You might answer this by first considering how many tennis balls could fit in a dresser, then estimating how many dressers might fit in a lane, then multiplying that by the number of lanes in a pool. \\

But what if you are asked one of these questions and you have \emph{absolutely no clue}? Is there any way to prepare for these questions, ace them, and  fulfill your dreams of becoming a consultant?\\

Don't worry, KCICK is here for you.\\

KCICK will be a query language that finds and retrieves data from a database. The database will provide a means of storing important information and facts and performing various calculations before displaying the final result. In short, our project will be to design a user-friendly language that can be used to solve and answer Fermi problems. \\

{\large{\textbf{(b) Design Principles }}}\\

Our goal is to keep KCICK simple and direct {\footnotesize(for our econ friends)}. To this end, the design of our language will mimic that of the metric system. The foundation of our language will be composed of "base units", which are our standard units of measurements that can be used to measure every other type of object in our language. The language will be used much like a "natural language", where the user should be able to supply input, typed out like a regular question, and the language will be able to recognize certain keywords and "vocab" and retrieve the measurements for these objects in the database.\\

{\large{\textbf{(c) Examples }}}  \\

\#1) \underline{How many}  \textbf{tennis balls} can \underline{fit in} an \textbf{Olympic sized pool}? 
\begin{itemize}
    \item Parse and recognize key phrases "How many," and "fit in"
    \item Also recognize primitives "tennis ball" and "Olympic sized pool"
    \item Query relevant information from database 
    \item Keyword "fit" tells our language to query data regarding sizes
    \item Olympic pools = 10 lanes = 100 dressers = 50 tennis balls
    \item Answer: There are approximately 5000 tennis balls in an Olympic sized pool.
\end{itemize}

             
\#2) \underline{How many} \textbf{Big Macs} are \underline{sold in} \textbf{New York City} every \textbf{day}? 
\begin{itemize}
    \item Parse and recognize key phrases "How many," and "sold in"
    \item Also recognize primitives "Big Macs" and "New York City" and "day"
    \item Query relevant information from database 
    \item Keyword "sold" tells our language to query data related to commerce/eceonomic statistics
    \item New York City = 50 McDonald's = 300 Big Macs sold a day 
    \item Answer: There are approximately 15000 Big Macs sold in New York City per day.
\end{itemize}

\#3) \underline{How many} \textbf{chalkboards} are \underline{there in} \textbf{Williams College}?
\begin{itemize}
    \item Parse and recognize "How many," and "there in"
    \item Query relevant information from database 
    \item Keyword "there" tells our language to query data regarding known locations/buildings/establishments
    \item Williams College = 2 libraries and 50 classrooms = 30 chalkboards per library and 1 chalkboard per classroom
    \item Answer: There are approximately 110 chalkboards in Williams College.
\end{itemize}

\vspace{10pt}
             
{\large{\textbf{(d) Language Concepts }}}\\  

KCICK is essentially a \emph{smarter} version of Google search--its goal is to answer estimation questions that Google may not find the answer on the web. Since Fermi questions are almost always asked in regular forms, users only need to 
\begin{itemize}
    \item understand what they want to ask (e.g. how many basketballs can fit in a Boeing-747?)
    \item make sure they use certain keywords (syntax), like 
    \begin{itemize}
        \item "How many", "How often", etc.
        \item "sold in", "there in", "fit in", "
    \end{itemize}
    \item include search terms that are objects defined in our language (e.g. basketball, pool, plane).
\end{itemize}
The key idea is to set a quantity you want to estimate with certain constraints. Assuming that the user follows the grammatical and vocabulary rules of KCICK syntax, the parser should be able to identify the keywords and objects, combine these together via calculations, and output an answer. \\

\newpage
{\large{\textbf{(e) Syntax }}}\\

Following is an informal syntax for KCICK. \\

First we have the overarching non-terminal ``question", which will basically be the entire user input:
\begin{verbatim}
    <question>::= <header> <object> <category> <constraint>
\end{verbatim}
The syntax very much replicates that of standard English. For example, the Fermi question
\begin{center}
"How many Big Macs are sold in New York City every day?"
\end{center}
will be broken down into 
\begin{verbatim}
    <header> = "How many" 
    <object> = "Big Mac"
    <category = "sold in"
    <constraint> = <object><unit> = "New York City" "day"
\end{verbatim}

Now let's look at the individual components. 
First, the ``header'' is the first indicator of what type of answer we are trying to estimate: 
\begin{verbatim}
    <header> ::= "How many"
               | "How often"
               | etc
\end{verbatim}
For example, if the ``header" is "How many", KCICK will understand that the user wants to answer a question regarding quantities, as opposed to frequencies in the case when the ``header'' is ``How often."\\

Next, is ``object":
\begin{verbatim}
    <object>::= (known objects (e.g. baseballs, Big Macs, etc.))
\end{verbatim}
This type will be represented as a tuple of two strings: the first string representing the \textit{name} of the object and second, a tag associated with what kind of data we are looking for. This basically corresponds to the ``row'' and ``column'' of the data we are looking at. Based on these strings, KCICK will query values from the database.\\

Internally, each ``object" will correspond to a value:
\begin{verbatim}
    <value>::= float
\end{verbatim}
For example, it  may be the size of a tennis ball, the population of New York City, or the volume of a swimming pool. Data will be stored in a \textit{database}, which needs to be further thought about in terms of implementation. \\ 

The third component is ``category'' which determines the type of the quantity we want to estimate :
\begin{verbatim}
    <category> ::= "fit in"
                | "sold in"
                | "found in"
                | "there in", etc
\end{verbatim}
This syntax will determine the ``tag" of the objects we will query. For example, the ``category'' of ``sold in" will tell KCICK to look up the value in the ``consumer statistics" column of the row ``Big mac". \\

Finally, the ``constraint'' gives KCICK the basis for making estimations about some data regarding the first ``object'':
\begin{verbatim}
    <constraint> ::= <object> 
                   | <object><unit>
\end{verbatim}
A constraint can either be a stand alone ``object'' we will compare our first ``object'' against, or a combination of an ``object'' and a unit that describes it. \\

For example, the first case is when the question asks "How many tennis balls can fit in an Olympic sized pool?" The constraint is an \textit{Olympic sized pool} which is a stand alone object that does not require further information. We pass on the same ``tag'' on the first object ``tennis ball" and look up the ``size" information of the swimming pool. \\

An example of the second case is the question "How many Big Macs are sold in New York City every day?" The constraint is a combination of \textit{New York  City} and \textit{day}. The latter is a base unit for our ``category" type which was ``consumer statistics". This could have been ``month", or "financial year," etc. \\

{\large{\textbf{(f) Semantics}}} \\

The \textit{primitives} of our language are data, headers, objects, categories, and constraints. We will have a primitive that represents the smallest unit of measure. For example, if our primitive is the object, "ping-pong ball", everything else in our language will be measured in terms of quantity of ping-pong balls. Since ping-pong balls are very small and not always the best way to measure certain objects given their shape, we might include additional primitives such as "Twix candy bars" or "Principles of Programming Languages textbooks". The data will simply be floats that represent the quantity, size, or frequency (depending on the tag) of the object. And finally, the question 

The actions in this language will require fetching data and performing calculations.\\
Let's look at example \#2) How many Big Macs are sold in New York City every day?\\

As said before, the "logic chain" includes

\begin{verbatim} 
    New York City -->  50 McDonald's --> 300 Big Macs 
\end{verbatim}
\subsection{Fetching Data}
This type of fetching could be done recursively, searching for relevant attributes until we arrive at our "destination" object.

\subsection{Performing calculations}
We will need to combine the data in a productive manner that helps us arrive at the answer. The calculations involved in this example would be multiplying 50 by 300, since each McDonald's sells 300 Big Macs and New York City has 50 McDonald's. 

\subsection{Representation}
Our program is a database, which will represented by a table data structure. The rows will correspond to the name of the object, and the column will correspond to the tag that that object is associated with. So in the "fetching" action, the program would match the name of the object of interest (a string) with the row values, and match the tag of that object (a string) with the column values. This will allow the program to locate the "metric conversion" that we want and retrieve the relevant data, to be used in performing calculations.

\subsection{Sample Abstract Syntax Trees}
\#1) \underline{How many}  \textbf{tennis balls} can \underline{fit in} an \textbf{Olympic sized pool}? 
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        ["tennis balls"]
    ]
    [$<$category$>$
        ["fit in"]
    ]
    [$<$constraint$>$
        [$<$object$>$
            ["Olympic sized pool]
        ]
    ]
]
\end{forest}
\end{center}

\#2) \underline{How many} \textbf{Big Macs} are \underline{sold in} \textbf{New York City} every \textbf{day}? 
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        ["Big Mac"]
    ]
    [$<$category$>$
        ["sold in"]
    ]
    [$<$constraint$>$
        [$<$object$>$
            ["New York City"]
        ]
        [$<$unit$>$
            ["day"]
        ]
    ]
]
\end{forest}
\end{center}
\#3) \underline{How many} \textbf{chalkboards} are \underline{there in} \textbf{Williams College}?
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        ["chalkboard"]
    ]
    [$<$category$>$
        ["there in"]
    ]
    [$<$constraint$>$
        [$<$object$>$
            ["Williams College"]
        ]
    ]
]
f\end{forest}
\end{center}

\subsection{Evaluation}
Evaluation begins when the user provides input in the form of a question, otherwise known as a "query". Then, the program will perform the two actions 1) fetching data and 2) performing calculations until the output is reached. The output will likely be a quantity of type float that is returned to the user as the answer to their Fermi question.

For question 1, we can consider a DFS traversal of the abstract syntax tree. First, we would examine the header, "How many" and recognize that we are looking for a quantity. Then, we would find the object of interest, which would be "tennis ball". Next, we would find the category using the keywords "fit in" from the question and realize that we are looking for some information regarding size. Lastly, we find our constraints, which is an object that is an "Olympic sized pool". After finding this information, we would perform the fetch operations and calculation operations as mentioned above, eventually arriving at our output, and returning to the user the answer of 5000 tennis balls!

\end{homeworkProblem}
\end{document}
