
\documentclass{article}

\usepackage{fancyhdr, extramarks, amsmath, amsthm, amsfonts, tikz, titling}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode, forest, listings, forest}
\usetikzlibrary{automata,positioning}

% Basic Document Settings
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in
\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\rfoot{\hmwkTitle}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\setlength\parindent{0pt}

% Create Problem Sections

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Q1. Project Proposal}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{ \exitProblemHeader{homeworkProblemCounter}}
%
% Homework Details
%
\newcommand{\hmwkTitle}{Homework 8}
\newcommand{\hmwkDueDate}{November 8, 2018}
\newcommand{\hmwkClass}{CSCI 334 Principles of PL }
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Professor Dan Barowy}
\newcommand{\hmwkAuthorName}{{3013644,3023651}}

%
% Various Helper Commands
%
% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}
% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}
% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}
% Integral dx
\newcommand{\dx}{\mathrm{d}x}
% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}
% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\renewcommand{\maketitle}{\bgroup\vspace*{-0.75in}
\setlength{\parindent}{0pt}
\begin{flushleft}
\noindent\rule{6.5in}{0.6pt}\\[3mm]
{\Large\textbf{\hmwkClass: \hmwkTitle}}\\[2mm]
\textit{\hmwkClassInstructor\ \hmwkClassTime} \\ 
\normalsize {\small Due:\ \hmwkDueDate\ at 10:00pm} \hfill 
\textbf{ID: 3013644, 3023651 $\;$}\\
\noindent\rule{6.5in}{0.6pt}
\end{flushleft}\egroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\thispagestyle{plain}
\maketitle
\renewcommand{\part}[1]{\textbf{\large Part
\Alph{partCounter}}\stepcounter{partCounter}\\}

\begin{homeworkProblem}
\vspace{20pt}
\begin{center}
{\fontfamily{qcr}\selectfont
\Large{\textbf{"KCICK: the \underline{K}CICK  \underline{C}onsulting \underline{I}nterview \underline{C}rac\underline{K}er"}}
}
\end{center}
\fontfamily{phv}\selectfont
\vspace{20pt}
{\large \textbf{(a) Introduction }} \\

Management consulting is a dream job for every Williams student. Well, at least that's what our \textit{non-CS} friends say.\\ 

One of the most notorious aspects of consulting interviews are the Fermi problems. These are problems that require a fast and rough estimation of quantities that may be hard to measure physically. One example of a Fermi problem is "How many tennis balls could fit in an Olympic sized pool?" You might answer this by first considering how many tennis balls could fit in a dresser, then estimating how many dressers might fit in a lane, then multiplying that by the number of lanes in a pool. \\

But what if you are asked one of these questions and you have \emph{absolutely no clue}? Is there any way to prepare for these questions, ace them, and  fulfill your dreams of becoming a consultant?\\

Don't worry, KCICK is here for you.\\

KCICK will be a query language that finds and retrieves data from a database. The database will provide a means of storing important information and facts and performing various calculations before displaying the final result. In short, our project will be to design a user-friendly language that can be used to solve and answer Fermi problems. \\

{\large{\textbf{(b) Design Principles }}}\\

Our goal is to keep KCICK simple and direct {\footnotesize(for our econ friends)}. To this end, the design of our language will mimic that of the metric system. The foundation of our language will be composed of "base units", which are our standard units of measurements that can be used to measure every other type of object in our language. The language will be used much like a "natural language", where the user should be able to supply input, typed out like a regular question, and the language will be able to recognize certain keywords and "vocab" and retrieve the measurements for these objects in the database.\\

{\large{\textbf{(c) Examples }}}  \\

\#1) \underline{How many}  \textbf{tennis balls} can \underline{fit in} an \textbf{Olympic sized pool}? 
\begin{itemize}
    \item Parse and recognize key phrases "How many," and "fit in"
    \item Also recognize primitives "tennis ball" and "Olympic sized pool"
    \item Query relevant information from database 
    \item Keyword "fit" tells our language to query data regarding sizes
    \item Olympic pools = 10 lanes = 100 dressers = 50 tennis balls
    \item Answer: There are approximately 5000 tennis balls in an Olympic sized pool.
\end{itemize}

             
\#2) \underline{How many} \textbf{Big Macs} are \underline{sold in} \textbf{New York City} every \textbf{day}? 
\begin{itemize}
    \item Parse and recognize key phrases "How many," and "sold in"
    \item Also recognize primitives "Big Macs" and "New York City" and "day"
    \item Query relevant information from database 
    \item Keyword "sold" tells our language to query data related to commerce/eceonomic statistics
    \item New York City = 50 McDonald's = 300 Big Macs sold a day 
    \item Answer: There are approximately 15000 Big Macs sold in New York City per day.
\end{itemize}

\#3) \underline{How many} \textbf{chalkboards} are \underline{there in} \textbf{Williams College}?
\begin{itemize}
    \item Parse and recognize "How many," and "there in"
    \item Query relevant information from database 
    \item Keyword "there" tells our language to query data regarding known locations/buildings/establishments
    \item Williams College = 2 libraries and 50 classrooms = 30 chalkboards per library and 1 chalkboard per classroom
    \item Answer: There are approximately 110 chalkboards in Williams College.
\end{itemize}

\vspace{10pt}
             
{\large{\textbf{(d) Language Concepts }}}\\  

KCICK is essentially a \emph{smarter} version of Google search--its goal is to answer estimation questions that Google may not find the answer on the web. Since Fermi questions are almost always asked in regular forms, users only need to 
\begin{itemize}
    \item understand what they want to ask (e.g. how many basketballs can fit in a Boeing-747?)
    \item make sure they use certain keywords (syntax), like 
    \begin{itemize}
        \item "How many", "How often", etc.
        \item "sold in", "there in", "fit in", "
    \end{itemize}
    \item include search terms that are objects defined in our language (e.g. basketball, pool, plane).
\end{itemize}
The key idea is to set a quantity you want to estimate with certain constraints. Assuming that the user follows the grammatical and vocabulary rules of KCICK syntax, the parser should be able to identify the keywords and objects, combine these together via calculations, and output an answer. \\

\newpage
{\large{\textbf{(e) Syntax }}}\\

Following is an informal syntax for KCICK. \\

First we have the overarching non-terminal ``question", which will basically be the entire user input:
\begin{verbatim}
    <question>::= <header> <object> <category> <object>
\end{verbatim}

Now let's look at the individual components. 
First, the ``header'' is the first indicator of what type of answer we are trying to estimate: 
\begin{verbatim}
    <header> ::= HowMany 
               | HowOften
               | etc
\end{verbatim}
HowMany is a type of header that consists of the string, "How many". This tells us that the user wants to answer a question regarding quantities, as opposed to frequencies in the case when the ``header'' is ``How often."\\

Next, is ``object":
\begin{verbatim}
    <object>::= Main
              | Compare
\end{verbatim}
Main and Compare are the two types of objects in KCICK. The Main object will be a string that represents the object of interest, and the Compare object will be the object being compared against.
\begin{verbatim}
    Main ::= "(some string)"
    Compare ::= "(some string)"
\end{verbatim}

The third component is ``category'' which determines the type of the quantity we want to estimate :
\begin{verbatim}
    <category> ::= FitIn
                 | SoldIn
                 | etc
\end{verbatim}
FitIn and SoldIn are two types of categories. This syntax will determine the ``tag" of the objects we will query. For example, the ``category'' of ``sold in" will tell KCICK where to look in the database for the relevant information.

The syntax very much replicates that of standard English. For example, the Fermi question
\begin{center}
"How many oranges can fit in a truck?"
\end{center}
will be broken down into 
\begin{verbatim}
    <header> = "How many" 
    <object> = "oranges"
    <category = "fit in"
    <compare> = "truck"
\end{verbatim}

{\large{\textbf{(f) Semantics}}} \\

The \textit{primitives} of our language are data, headers, objects, categories, and constraints. We will have a primitive that represents the smallest unit of measure. For example, if our primitive is the object, "ping-pong ball", everything else in our language will be measured in terms of quantity of ping-pong balls. Since ping-pong balls are very small and not always the best way to measure certain objects given their shape, we might include additional primitives such as "Twix candy bars" or "Principles of Programming Languages textbooks". The data will simply be floats that represent the quantity, size, or frequency (depending on the tag) of the object. And finally, the question 

The actions in this language will require fetching data and performing calculations.\\
Let's look at example \#2) How many Big Macs are sold in New York City every day?\\

As said before, the "logic chain" includes

\begin{verbatim} 
    New York City -->  50 McDonald's --> 300 Big Macs 
\end{verbatim}
\subsection{Fetching Data}
This type of fetching could be done recursively, searching for relevant attributes until we arrive at our "destination" object.

\subsection{Performing calculations}
We will need to combine the data in a productive manner that helps us arrive at the answer. The calculations involved in this example would be multiplying 50 by 300, since each McDonald's sells 300 Big Macs and New York City has 50 McDonald's. 

\subsection{Representation}
Our program is a database, which will represented by a table data structure. The rows will correspond to the name of the object, and the column will correspond to the tag that that object is associated with. So in the "fetching" action, the program would match the name of the object of interest (a string) with the row values, and match the tag of that object (a string) with the column values. This will allow the program to locate the "metric conversion" that we want and retrieve the relevant data, to be used in performing calculations.

\subsection{Sample Abstract Syntax Trees}
\#1) \underline{How many}  \textbf{tennis balls} can \underline{fit in} an \textbf{Olympic sized pool}? 
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        [Main
        ["tennis balls"]
        ]
    ]
    [$<$category$>$
        ["fit in"]
    ]
    [$<$object$>$
        [Compare
        ["Olympic sized pool"]
        ]
    ]
]
\end{forest}
\end{center}

\#2) \underline{How many} \textbf{Big Macs} are \underline{sold in} \textbf{New York City}? 
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        [Main
        ["Big Macs"]
        ]
    ]
    [$<$category$>$
        ["sold in"]
    ]
    [$<$object$>$
        [Compare
        ["New York City"]
        ]
    ]
]
\end{forest}
\end{center}
\#3) \underline{How many} \textbf{chalkboards} are \underline{there in} \textbf{Williams College}?
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        [Main
        ["chalkboard"]
        ]
    ]
    [$<$category$>$
        ["there in"]
    ]
    [$<$object$>$
        [Compare
        ["Williams College"]
        ]
    ]
]
f\end{forest}
\end{center}

\subsection{Evaluation (as of 11/15/18)}
Evaluation begins when the user provides input in the form of a question, otherwise known as a "query". Then, the program will perform the two actions 1) fetching data and 2) performing calculations until the output is reached. The output will likely be a quantity of type float that is returned to the user as the answer to their Fermi question.

For now, we can only parse objects of one word length. 
Let's consider the question: "How many oranges can fit in a pool?"

Our parser returns AST:
\begin{center}
\begin{forest}
[$<$question$>$
    [$<$header$>$
        ["How many"]
    ]
    [$<$object$>$
        [Main
        ["oranges"]
        ]
    ]
    [$<$category$>$
        ["fit in"]
    ]
    [$<$object$>$
        [Compare
        ["pool"]
        ]
    ]
]
\end{forest}
\end{center}

First, we would examine the category, "fit in", which tells us where in our database to search. Our database will ultimately be a map of strings to maps (and these "interior" maps will be from strings to floats). So it will be of type \begin{verbatim} Map<string, Map <string, float>> \end{verbatim} The category string will be the key, and lead us to another map with various objects as keys and floats as values. For this week's implementation, our database is just a map from strings to floats, since we only have one category. Then, we find the value in the map by using the Main object and Compare object as keys, divide their values, and return the answer as 12.5 oranges! 

\end{homeworkProblem}
\end{document}
